# Nameful contextual notation for embedded theories

Nameful notation for binders is universally used in practical programming
languages and mathematical notation. But if we want to formalize stuff about a
language that's deeply embedded in some metatheory, the picture is not so clear.

- Higher-order abstract syntax (HOAS) is great when it works, but it's not always
  applicable. Syntactic translations or model constructions that do fancy things
  with contexts are often not expressible in HOAS frameworks. For example
  - CPS, ANF translation
  - Closure conversion
  - Many optimizations, like dead code elimination
  - Some parametricity translations

- Named variables have been used in numerous papers, but often in an
  uncomfortably fuzzy way, with a huge amount of implicitly assumed formal
  boilerplate.

I propose a nameful notation for embedded theories, which can be
straightforwardly desugared into some algebraic/categorical calculus. Benefits:

- It's a *lot* more readable than nameless notation, already for mildly
  complicated things.
- We can do complete equational reasoning on nameful the notation, IMO more easily
  than on the nameless one.
- We can use the notation very generally, whenever we have a well-behaved notion
  of "context" and "substitution". In particular, it certainly works for
  first-order models of any second-order algebraic theory.

Here I'm focusing on using the notation in pen-and-paper
formalization. Supporting it in proof assistants would be nice too, but it'd
take more thought and quite a bit of work.

## Setup (categories with families)

I'm taking categories-with-families (CwF) as my specification of contexts
and substitutions, but you can swap it out to any other equivalent setup.

Let's recap CwFs. A CwF has the following underlying sets:

    Con : Set                      -- context
	Sub : Con → Con → Set          -- substitution
	Ty  : Con → Set                -- type
	Tm  : (Γ : Con) → Ty Γ → Set   -- term

I'll write Γ, Δ, Ξ for contexts, σ, δ, ν for substitutions, A, B, C for types
and t, u, v for terms.

Parallel substitutions (Sub) form a category, with the empty context ∙ being the
terminal object.

    _∘_ : Sub Δ Ξ → Sub Γ Δ → Sub Γ Ξ
	id  : Sub Γ Γ
	_   : id ∘ σ = σ
	_   : σ ∘ id = σ
	_   : (σ ∘ δ) ∘ ν = σ ∘ (δ ∘ ν)
	∙   : Con
	()  : Sub Γ ∙
	_   : (σ : Sub Γ ∙) → σ = ()

A parallel substitution (σ : Sub Γ Δ) is, intuitively, a list of Δ-many terms
where each term is in context Γ. Hence, the empty substitution () is an empty
list of terms. Terms and types can be substituted:

    _[_] : Ty Δ → Sub Γ Δ → Ty Γ
	_[_] : Tm Δ A → (σ : Sub Γ Δ) → Tm Γ (A[σ])

Substitution is functorial for types and terms:

    A[id]    = t
	A[σ ∘ δ] = A[σ][δ]
    t[id]    = t
	t[σ ∘ δ] = t[σ][δ]

Contexts can be extended

    _,_ : (Γ : Con) → Ty Γ → Con

We can build substitutions ("cons" our lists) as follows:

    _,_ : (σ : Sub Γ Δ) → Tm Γ (A[σ]) → Sub Γ (Δ,A)
	fst : Sub Γ (Δ,A) → Sub Γ Δ
	snd : (σ : Sub Γ (Δ,A)) → Tm Γ (A[fst σ])
	_   : (fst σ, snd σ) = σ
	_   : fst (σ, t) = σ
	_   : snd (σ, t) = t
	_   : (σ, t) ∘ δ = (σ ∘ δ, t[δ])

That's it for CwFs.

In each CwF though, it's useful to make some derived definitions.
The *weakening substitution* drops the last entry from a context:

    wk : Sub (Γ, A) Γ
	wk := fst (id {Γ,A})

Here, id {Γ,A} : Sub (Γ,A) (Γ,A), and the curly braces are meant to be
an Agda-like implicit argument notation.

The *zero De Bruijn index* is the variable pointing to the last context
entry:

    0 : Tm (Γ,A) (A[wk])
	0 := snd (id {Γ,A})

We can define every other De Bruijn index as iterated weakening of zero, so that
the index "n" is zero[wkⁿ], where wkⁿ is the n-fold composition of wk.

A CwF is perhaps not too simple, but it is a whole lot simpler than building up
the specification for some theory starting from untyped terms. The syntax of
some theory is obtained when we consider the specification as a *quotient
inductive-inductive definition*, where everything is freely generated by the
operations and quotiented by the equations.

If for some reason we start from untyped terms, we can still show that the
syntax and substitutions that we defined can be arranged into a CwF, when
appropriately quotiented, and that we have the expected induction principle for
it (i.e. it's an initial CwF).

Usually, we specify additional *type formers* on the top of a CwF, like function
types:

    Pi  : (A : Ty Γ) → Ty (Γ, A) → Ty Γ
	_   : (Pi A B)[σ] = Pi (A[σ]) (B[fst σ, 0])
	lam : Tm (Γ,A) B → Tm Γ (Pi A B)
	_   : (lam t)[σ] = lam (t[fst σ, 0])
	app : Tm Γ (Pi A B) → Tm (Γ, A) B
	_   : app (lam t) = t                  -- beta
	_   : lam (app t) = t                  -- eta

This definition for application exploits the CwF structure so that we can get
nicely symmetric beta and eta rules. But it's actually equivalent to the "usual"
application:

    app : Tm Γ (Pi A B) → (t : Tm Γ A) → Tm Γ (B[id, t])

Also, CwFs can be generalized to support many different sorts with context
extensions.	For example, in cubical type theories we might have a sort and
a separate kind of context extension for intervals:

    Int   : Con → Set
	_,Int : Con → Con
	_,_   : (σ : Sub Γ Δ) → Int Γ → Sub Γ (Δ,Int)

Informally, this lets us mix interval binders and ordinary binders in a context,
like as in Γ, x : Nat, i : Int ⊢ i : Int. Formally, the `i : Int` is a different
kind of context extension.

(A general description of theories with "sensible" contexts and substitutions
is "second-order generalized algebraic theory", see e.g.
https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2024.10 )


## The notation

In ordinary nameful notation for calculi, we assign names to certain terms,
those which are iterated weakenings of the zero De Bruijn index.

The idea here is to also assign names to certain substitutions, the iterated
weakenings themselves. There's not much more to it!

Let's start with a minimal example. We have the embedded syntax of some theory,
as a CwF with type formers. We only assume Pi as before now. We define a trivial
"copy" operation by recursion on terms, which just rebuilds the same term, and
we don't do anything with contexts, types and substitutions. In a nameless
Agda-like notation, we might write something like:

    copy : Tm Γ A → Tm Γ A
	copy (snd σ) := snd σ
	copy (t[σ])  := (copy t)[σ]
	copy (app t) := app (copy t)
	copy (lam t) := lam (copy t)

These four cases cover every possible way of constructing a term in a CwF+Pi, so
it's enough to interpret them to get a recursive function on terms. Also, we
need to show that all term equations are preserved, but that's trivial now so we
skip it.

In nameful notation:

    copy : Tm Γ A → Tm Γ A
	copy (snd σ) := Λ γ. snd σ γ
	copy (t[σ])  := Λ γ. copy t (σ γ)
	copy (app t) := Λ (γ, α). app (copy t γ, α)
	copy (lam t) := Λ γ. lam α. copy t (γ, α)

- We use Λ to introduce names for substitutions.
- We overload whitespace for substitution and for substitution composition,
  i.e. we can use "t σ" instead of t[σ] and "σ δ" instead of σ ∘ δ.
- If I write Λ γ., then γ is the name of the identity substitution from some Γ
  to Γ.  When I refer to γ from under some binders, it gets weakened the same
  way as ordinary term variables in nameful notation.
- If I write Λ (γ, α), then (γ, α) refers to the identity substitution from some
  (Γ,A) to (Γ,A), so γ is now fst id and α is snd id. Again, everything gets
  weakened when we use names from under binders.
- I use the standard desugaring scheme for ordinary term binders such as lam.

Let's mechanically desugar the above right hand sides:

    (Λ γ. snd σ γ) = (snd σ)[id] = snd σ
	(Λ γ. copy t (σ γ)) = (copy t)[σ ∘ id] = (copy t)[σ]
	(Λ (γ, α). app (copy t γ, α)) = app ((copy t)[fst id, snd id]) = app ((copy t)[id]) = app (copy t)
	(Λ γ. lam α. copy t (γ, α)) = lam ((copy t)[fst id, snd id]) = lam ((copy t)[id]) = lam (copy t)

Let's redefine some basic terms and substitutions in a nameful way:

    id : Sub Γ Γ    wk : Sub (Γ, A) Γ
	id := Λ γ. γ    wk = Λ (γ,_). γ

	_∘_ : Sub Δ Ξ → Sub Γ Δ → Sub Γ Ξ
	σ ∘ δ := Λ γ. σ (δ γ)

	0 : Tm (Γ,A) (A[wk])
	0 := Λ (_,α). α

However, we can already be nameful in contexts as well, like:

    0 : Tm (γ : Γ, α : A γ) (A γ)
	0 := Λ (_, α). α

The desugaring of **contexts** is as follows:

- If I write `γ : Γ`, I bring into scope `γ` as the identity substitution.
- In each context extension, the type implicitly binds everything on the left, and
  with each new binder we weaken all names in scope.
- In Tm Γ A, the type A can refer to names from  Γ
- In Sub Γ Δ, Δ can refer to names from Γ.

The previous type for 0 is desugared as follows:

    Tm (γ : Γ, α : A γ) (A γ) = Tm (Γ, A[id]) (A[fst id]) = Tm (Γ, A) (A[wk])

Lastly, let me introduce the following additional sugary notation:

- We may write Γ => Ty   instead of Ty Γ
- We may write Γ => Tm A instead of Tm Γ A
- We may Write Γ => Δ    instead of Sub Γ Δ

Thus, we may write:

    0 : (γ : Γ, A γ) => Tm (A γ)
	0 := Λ (_, α). α

	id : Γ => Γ
	id := Λ γ. γ

## Specifying some type formers, namefully

While the Pi type is pretty easy to specify in unnamed CwF operations, if we
want to rigorously write out specifications for complicated inductive types
like identity types or W-types, that's surprisingly tedious.

Let's start with the somewhat simpler **natural numbers**.

    Nat  : Γ => Ty
	zero : Γ => Tm Nat
	suc  : (Γ => Tm Nat) → (Γ => Tm Nat)

Here, note that we write Γ => Tm Nat instead of (γ : Γ) => Tm (Nat γ). This is
justified, since (γ : Γ) => Tm (Nat γ) is the same as (γ : Γ) => Tm (Nat[id]),
which is Γ => Tm Nat.

In general, we could just drop every identity substitution in the notation, but
it's probably not a good idea. In the case of Nat, since Nat, zero and suc are
all defined in arbitrary contexts, we can write them anywhere without having to
care about supplying the correct substitution.

The elimination principle:

    NatElim : (P  : (Γ, Nat) => Ty)
	          (pz : (γ : Γ) => Tm (P (γ, zero)))
			  (ps : (γ : Γ, n : Nat, P (γ, n)) => Tm (P (γ, suc n)))
			  (n  : Γ => Tm Nat)
	        → ((γ : Γ) => Tm (P (γ, n)))

This desugars to:

    NatElim : (P  : Ty (Γ, Nat))
	          (pz : Tm Γ (P[id, zero]))
			  (ps : Tm (Γ, Nat, P) (P[fst (fst id), suc (snd (fst id))]))
			  (n  : Tm Γ Nat)
	        → Tm Γ (P[id, n])

We also have some equations:

    _ :  NatElim P pz ps n σ
	   = NatElim (Λ (γ,n). P(γ σ, n)) (pz σ) (Λ (γ, n, pn). ps (γ σ, n, pn)) (n σ)

    _ : NatElim P pz ps zero    = pz
	_ : NatElim P pz ps (suc n) = Λ γ. ps (γ, n, NatElim P pz ps n)

Note that I can choose to "eta-expand" or not expand terms. For example,

    pz : (γ : Γ) => Tm (P (γ, zero))
	σ  : Δ => Γ

So

	pz σ = pz[σ]   -- desugared type: Tm Δ (P [σ, zero])

But also

    (Λ γ. pz (γ σ)) = pz[id ∘ σ] = pz[σ]

I can also eta-expand equations. Instead of having

    NatElim P pz ps zero = pz

I could write

    NatElim P pz ps zero γ = pz γ

where γ is universally quantified, and it means the same. I already hinted at this in
the suc beta rule:

    NatElim P pz ps (suc n) = Λ γ. ps (γ, n, NatElim P pz ps n)

here the RHS desugars to

    ps[id, n, NatElim P pz ps n]

but I can also write, for universally quantified γ:

    NatElim P pz ps (suc n) γ = ps (γ, n, NatElim P pz ps n)

Let's continue with the **identity type**. A first attempt:

    Id   : {A : Γ => Ty} → ((γ : Γ) => Tm (A γ)) → ((γ : γ) => Tm (A γ)) → Γ => Ty
	refl : (t : (γ : Γ) => Tm (A γ)) → ((γ : Γ) => Tm (Id (t γ) (t γ))

This is still tolerable, but at this point we might want to switch to a
specification which is better suited to nameful notation.

    Id   : {A : Γ => Ty} → (γ : Γ, A γ, A γ) => Ty
	refl : {A} → (γ : Γ, t : A γ) => Tm (Id {A} t t)

	_    : Id {A} (σ, x, y) = Λ γ. Id {A σ} (γ, x, y)
	_    : refl {A} (σ, t)  = Λ γ. refl {A σ} (γ, t)

	J    : {A  : Γ => Ty}
	       {a  : (γ : Γ) => Tm (A γ)}
		   (B  : (γ : Γ, a' : A γ, e : Id (γ, a γ, a')) => Ty)
		   (Br : (γ : Γ) => Tm (B (γ, a γ, refl (a γ))))
		   →
		   (γ : Γ, a' : A γ, e : Id (γ, a γ, a')) => Tm (B (γ, a γ, a', e))

    _    : J {A}{a} B Br (σ, a', e) = Λ γ. J {A σ}{a σ}(Λ (δ, a', e). B (δ σ, a', e))(Br σ) (γ, a', e)

	_    : J {A}{a} B Br (γ, a, refl a) = Br γ
