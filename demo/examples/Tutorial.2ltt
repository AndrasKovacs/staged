
{-
This is a multi-line comment.
-}

-- This is a line comment. As you see, 2ltt follows Haskell commenting syntax.

{-
Let's look at how to process file. If you have "2ltt" on PATH, the typical way
to use it is by piping a file to its standard input:

  > cat Basics.2ltt | 2ltt COMMAND

Commands are the following:

- "elab": prints elaboration output. This prints all inferred staging
  operations, but does not print anything inserted by general inference, namely
  type annotations, implicit arguments and implicit lambdas.
- "elab-verbose": print elaboration output, showing almost all data inserted by
  elaboration. It also lists all metavariables and their solutions in the
  preface of the output.
- "stage": prints staging output, doesn't show inserted implicits and annotations.
- "stage-verbose": prints staging output, shows inserted implicits and annotations.
- "nf": prints the verbose normal form of the input program, together with its type.
- "type": prints the verbose normal type of the input program.

"stage" requires that all metavariables are solved. It throws an error on an
unsolved meta, and advises you to use "elab-verbose" to look at occurrences
of the meta (sorry for the lack of informative message here).
-}

{-
The whole file must be a single expression. We can use let-definitions to
introduce as many "top-level" bindings as we want. At the end of the file there
must be a single "main" expression, as the body under the nested let-s. When we
run "nf" and "type", this is the directly relevant part in the output.
-}

{-
We have two universes:

   U0 is the universe of runtime types, itself a runtime type
   U1 is the universe of static types, itself a static type

0 and 1 are stages, and they are *not* universe indices in the usual sense of
type theory.  In fact, we have type-in-type separately at both stages:
-}

let typeInType0 : U0 := U0;
let typeInType1 : U1 =  U1;

{-
Note the "let"-syntax: it can be either

   let ident : type := def; body

or

   let ident : type = def; body

We will shortly explain the difference between = and :=.

Type annotations can be omitted, and we can shadow any previous definition:
-}

let typeInType0 := U0;
let typeInType1 = U1;

{-
In the "elab-verbose" output, the omitted annotations are filled in.
-}

{-
Let's look at the difference between "=" and ":=" in "let".

  - "=" introduces a static, (synonymously, meta-level or compile time) binding.
  - ":=" introduces a runtime (object-level) binding.

2ltt is a staged language: static bindings are evaluated at compile time, and
they are never present in staging output. The staging output contains runtime
code, generated by running static computations.

  - A static type has type U1. Note that U1 is a static type. Static types are
    computed away during staging.
  - A static term/value has type A for A : U1. These are also computed away.
  - A runtime type has type U0; again note that U0 : U0.
  - A runtime value has type A for A : U0. Runtime values may be computed by

Typing let-definitions:

  - "let x : A = t; u"          A, t, u must be all static
  - "let x : A := t; u"         A, t, u must be all runtime

You might ask, how is it possible then to have the following (which we already
have in this file!)

  let x : A = t;
  let y : B = u;
  v

The answer is that *staging operations* can be used to move between stages, and
2ltt automatically inserts missing staging operations. We have three operations:

  - For A : U0 we have ^A : U1. This is called *lifting*. A value of ^A is
    a metaprogram which returns a runtime code expression with type A.
  - For A : U0 and t : A we have <t> : ^A. This called *quoting*.
    <t> is the metaprogram which immediately returns the t expression.
  - For A : U0 and t : ^A we have [t] : A. This is *splicing*. A splice
    [t] inserts the output of the metaprogram t into runtime code.
  - We have [<t>] = t and <[t]> = t definitionally.

Now, I have the following program input to 2ltt:

  let x : U0 := U0; let y : U1 = U1; x

2ltt inserts staging operations in the "elab" output:

  let x : U0 := U0; [let y : U1 = U1; <x>]

Here, since x is bound at runtime, the let body must be runtime as well.
So 2ltt *splices* the expression into the let body. In turn, in

  let y : U1 = U1; <x>

we need to *quote* x to <x>, because now this is a static program, so we cannot
directly mention the runtime variable x (I mean, we can, but 2ltt will infer all
splices and quotes).

The output of "stage" is the following for "let x : U0 := U0; [let y : U1 = U1; <x>]":

  let x : U0 := U0; x

This can computed in steps as:

  let x : U0 := U0; [let y : U1 = U1; <x>]
  let x : U0 := U0; [<x>]
  let x : U0 := U0; x

The static y binding gets evaluated, and since it's not used anywhere, it just
disappears.
-}

{-
Let's look at type formers. They work exactly as in usual type theories,
except we have the following restriction:

    every type/term former and eliminator stays within the same stage

A runtime function type must have runtime domain and codomain types, for example:
-}

let ex0 : U0 := U0 → U0;

{-
A static function type must have static domain and codomain types:
-}

let ex1 : U1 = U1 → U1;

{-
This brings us to *function types*. We can use either

  (x : A) → B

or

  (x : A) -> B

for dependent functions, and "A → B" or "A -> B" for non-dependent ones.
We can also group binders as in Agda:
-}

let ex2 : U1 = (a b c d : U1) → U1;

{-
We can write static and runtime polymorphic identity functions as follows:
-}

let explicitId1 : (A : U1) → A → A = λ A x. x;

let explicitId0 : (A : U0) → A → A := λ A x. x;

{-
I called these "explicit", because their arguments must be explicitly supplied:
-}

let ex3 : U1 = explicitId1 U1 U1;

{-
Usually, we instead use implicit type arguments. These work mostly the same as in Agda:
-}

let id1 : {A : U1} → A → A = λ x. x;
let id0 : {A : U0} → A → A := λ x. x;

{-
Implicit arguments can be explicitly applied, and can be also passed by argument name,
again, as in Agda.
-}

let ex4 : U1 = id1 U1;
let ex5 : U1 = id1 {U1} U1;
let ex6 : U1 = id1 {A = U1} U1;

let ex7 : {A B : U1} → A → B → A = λ {A}{B} x y. x;
let ex8 : {A B : U1} → A → B → A = λ {B = B} x y. x;

-- Annotated lambda binders:
let ex9 = λ {A : U1}(x : A). x;

-- We can omit binder types if they are inferable:
let ex10 : {A B} → A → B → A = λ x y. x;

-- We can use non-unicode lambda as well:
let ex11 : {A} → A → A = \x. x;

-- We can also put a hole anywhere, to be inferred:

let ex12 : {A : _} → A → A = λ x. id1 {_} x;

{-
We have *natural numbers* at both stages, as the following built-in constants:

  Nat1     : U1
  zero1    : Nat1
  suc1     : Nat1 → Nat1
  NatElim1 : (P : Nat1 → U1) → ((n : Nat1) → P n → P (suc1 n)) → P zero1 → (n : Nat1) → P n

  Nat0     : U0
  zero0    : Nat0
  suc0     : Nat0 → Nat0
  NatElim0 : (P : Nat0 → U0) → ((n : Nat0) → P n → P (suc0 n)) → P zero0 → (n : Nat0) → P n
-}



U0
