
{-
This is a multi-line comment.
-}

-- This is a line comment. As you see, 2ltt follows Haskell commenting syntax.

{-
Let's look at how to process file. If you have "2ltt" on PATH, the typical way
to use it is by piping a file to its standard input:

  > cat Basics.2ltt | 2ltt COMMAND

Commands are the following:

- "elab": prints elaboration output. This prints all inferred staging
  operations, but does not print anything inserted by general inference, namely
  type annotations, implicit arguments and implicit lambdas.
- "elab-verbose": print elaboration output, showing almost all data inserted by
  elaboration. It also lists all metavariables and their solutions in the
  preface of the output.
- "stage": prints staging output, doesn't show inserted implicits and annotations.
- "stage-verbose": prints staging output, shows inserted implicits and annotations.
- "nf": prints the verbose normal form of the input program, together with its type.
- "type": prints the verbose normal type of the input program.

"stage" requires that all metavariables are solved. It throws an error on an
unsolved meta, and advises you to use "elab-verbose" to look at occurrences
of the meta (sorry for the lack of informative message here).
-}

{-
The whole file must be a single expression. We can use let-definitions to
introduce as many "top-level" bindings as we want. At the end of the file there
must be a single "main" expression, as the body under the nested let-s. When we
run "nf" and "type", this is the directly relevant part in the output.
-}

{-
We have two universes:

   U0 is the universe of runtime types, itself a runtime type
   U1 is the universe of static types, itself a static type

0 and 1 are stages, and they are *not* universe indices in the usual sense of
type theory.  In fact, we have type-in-type separately at both stages:
-}

let typeInType0 : U0 := U0;
let typeInType1 : U1 =  U1;

{-
Note the "let"-syntax: it can be either

   let ident : type := def; body

or

   let ident : type = def; body

We will shortly explain the difference between = and :=.

Type annotations can be omitted, and we can shadow any previous definition:
-}

let typeInType0 := U0;
let typeInType1 = U1;

{-
In the "elab-verbose" output, the omitted annotations are filled in.
-}

{-
Let's look at the difference between "=" and ":=" in "let".

  - "=" introduces a static, (synonymously, meta-level or compile time) binding.
  - ":=" introduces a runtime (object-level) binding.

2ltt is a staged language: static bindings are evaluated at compile time, and
they are never present in staging output. The staging output contains runtime
code, generated by running static computations.

  - A static type has type U1. Note that U1 is a static type. Static types are
    computed away during staging.
  - A static term/value has type A for A : U1. These are also computed away.
  - A runtime type has type U0; again note that U0 : U0.
  - A runtime value has type A for A : U0.

Typing let-definitions:

  - "let x : A = t; u"          A, t, u must be all static
  - "let x : A := t; u"         A, t, u must be all runtime

You might ask, how is it possible then to have the following (which we already
have in this file!)

  let x : A := t;
  let y : B = u;
  v

The answer is that *staging operations* can be used to move between stages, and
2ltt automatically inserts missing staging operations. We have three operations:

  - For A : U0 we have ^A : U1. This is called *lifting*. A value of ^A is
    a metaprogram which returns a runtime code expression with type A.
  - For A : U0 and t : A we have <t> : ^A. This called *quoting*.
    <t> is the metaprogram which immediately returns the t expression.
  - For A : U0 and t : ^A we have [t] : A. This is *splicing*. A splice
    [t] inserts the output of the metaprogram t into runtime code.
  - We have [<t>] = t and <[t]> = t definitionally.

Now, I have the following program input to 2ltt:

  let x : U0 := U0; let y : U1 = U1; x

2ltt inserts staging operations in the "elab" output:

  let x : U0 := U0; [let y : U1 = U1; <x>]

Here, since x is bound at runtime, the let body must be runtime as well.
So 2ltt *splices* the expression into the let body. In turn, in

  let y : U1 = U1; <x>

we need to *quote* x to <x>, because now this is a static program, so we cannot
directly mention the runtime variable x (I mean, we can, but 2ltt will infer all
splices and quotes).

The output of "stage" is the following for "let x : U0 := U0; [let y : U1 = U1; <x>]":

  let x : U0 := U0; x

This can computed in steps as:

  let x : U0 := U0; [let y : U1 = U1; <x>]
  let x : U0 := U0; [<x>]
  let x : U0 := U0; x

The static y binding gets evaluated, and since it's not used anywhere, it just
disappears.
-}

{-
Let's look at type formers. They work exactly as in usual type theories,
except we have the following restriction:

    every type/term former and eliminator stays within the same stage

A runtime function type must have runtime domain and codomain types, for example:
-}

let ex0 : U0 := U0 → U0;

{-
A static function type must have static domain and codomain types:
-}

let ex1 : U1 = U1 → U1;

{-
This brings us to *function types*. We can use either

  (x : A) → B

or

  (x : A) -> B

for dependent functions, and "A → B" or "A -> B" for non-dependent ones.
We can also group binders as in Agda:
-}

let ex2 : U1 = (a b c d : U1) → U1;

{-
We can write static and runtime polymorphic identity functions as follows:
-}

let explicitId1 : (A : U1) → A → A = λ A x. x;

let explicitId0 : (A : U0) → A → A := λ A x. x;

{-
I called these "explicit", because their arguments must be explicitly supplied:
-}

let ex3 : U1 = explicitId1 U1 U1;

{-
Usually, we instead use implicit type arguments. These work mostly the same as in Agda:
-}

let id1 : {A : U1} → A → A = λ x. x;
let id0 : {A : U0} → A → A := λ x. x;

{-
Implicit arguments can be explicitly applied, and can be also passed by argument name,
again, as in Agda.
-}

let ex4 : U1 = id1 U1;
let ex5 : U1 = id1 {U1} U1;
let ex6 : U1 = id1 {A = U1} U1;

let ex7 : {A B : U1} → A → B → A = λ {A}{B} x y. x;
let ex8 : {A B : U1} → A → B → A = λ {B = B} x y. x;

-- Annotated lambda binders:
let ex9 = λ {A : U1}(x : A). x;

-- We can omit binder types if they are inferable:
let ex10 : {A B} → A → B → A = λ x y. x;

-- We can use non-unicode lambda as well:
let ex11 : {A} → A → A = \x. x;

-- We can also put a hole anywhere, to be inferred:

let ex12 : {A : _} → A → A = λ x. id1 {_} x;

{-
We have *natural numbers* at both stages, as the following built-in constants:

  Nat1     : U1
  zero1    : Nat1
  suc1     : Nat1 → Nat1
  NatElim1 : (P : Nat1 → U1) → ((n : Nat1) → P n → P (suc1 n)) → P zero1 → (n : Nat1) → P n

  Nat0     : U0
  zero0    : Nat0
  suc0     : Nat0 → Nat0
  NatElim0 : (P : Nat0 → U0) → ((n : Nat0) → P n → P (suc0 n)) → P zero0 → (n : Nat0) → P n
-}

{-
Let us look at some staging examples. First, we define some basic polymorphic functions.
-}

let const1 : {A B : U1} → A → B → A
  = λ x y. x;

let const0 : {A B : U0} → A → B → A
  := λ x y. x;

let comp1 : {A B C : U1} → (B → C) → (A → B) → A → C
  = λ f g x. f (g x);

let comp0 : {A B C : U0} → (B → C) → (A → B) → A → C
  := λ f g x. f (g x);

{-
Interestingly, we can use all of id0, id1, const0, const1, comp0 and comp1 in
*runtime code*. How is this possible, when e.g. id1 is a static function? We can
use lifting to make id1 compute on *expressions*:
-}

let ex13 : Nat0 := [id1 {^Nat0} <zero0>];

{-
ex13 is staged as follows:

  [id1 {^Nat0} <zero0>]
  [<zero0>]
  zero0

Staging annotations are a bit of mouthful here, but we can just omit them, and
2ltt inserts them:
-}

let ex14 : Nat0 := id1 zero0;

-- or even:
let ex15 := id1 zero0;

{-
So, we can freely use the polymorphic static functions, and they compute at compile time.

Let's look at composing two runtime functions, using static composition. Fully
explicitly:
-}

let ex16 : Nat0 → Nat0
  := λ x. [comp1 {^Nat0}{^Nat0}{^Nat0} (λ x. <suc0 [x]>) (λ x. <suc0 [x]>) <x>];

  -- stages to (λ x. suc0 (suc0 x))

{-
This is way more verbose, but once again we can simply write the following:
-}

let ex17 : Nat0 → Nat0
  := comp1 suc0 suc0;

{-
Note that 2ltt was able to convert (suc0 : Nat0 → Nat0) to ((λ x. <suc0 [x]>) : ^Nat0 → ^Nat0).

In general, we have the following isomorphism of types:

    ^((x : A) → B x) ≃ ((x : ^A) → ^(B [x]))

2ltt can transport along this isomorphism automatically. 2ltt
uses coercive subtyping, with the following rules.

  ──────    (inserts <_>)
  A ≤ ^A

  ──────    (inserts [_])
  ^A ≤ A

  ────────  (inserts ^_)
  U0 ≤ U1

      A' ≤ A      ∀ x. B x ≤ B' x
  ───────────────────────────────────   (eta-expands, coerces back-and-forth)
  ((x : A) → B x) ≤ ((x : A') → B' x)


The actual implementation is a bit more complicated, but you can generally
expect these coercions to work.
-}

{-
In contrast, the runtime comp0 is unchanged during staging:
-}

let ex18 : Nat0 → Nat0
  := comp0 suc0 suc0;  -- stages to itself

{-
We can also define *constants*, runtime values which are
always inlined:
-}

let three : Nat0 = suc0 (suc0 (suc0 zero0));

{-
Note the "="! This is elaborated to

   let three : ^Nat0 = <suc0 (suc0 (suc0 zero0))>

and it is spliced in whenever we use it in runtime code.
-}


{-
Let's move on to slightly more interesting examples with runtime data
structures. Right now, we only have Nat0 as a runtime inductive type, but we can
actually define Church-coded versions of a wide range of types, thanks to
type-in-type. We define runtime lists:
-}

let List0 : U0 → U0
  := λ A. (L : U0)(cons0 : A → L → L)(nil0 : L) → L;

let nil0 : {A} → List0 A
  := λ L c n. n;

let cons0 : {A} → A → List0 A → List0 A
  := λ a as L c n. c a (as L c n);

let foldr0 : {A B} → (A → B → B) → B → List0 A → B
  := λ f z as. as _ f z;

{-
From now on, we just view these definitions as primitive constants in the
following staging examples.

Let's define an inlined map function, explicitly:
-}

let explicitInlMap0 : {A : ^U0}{B : ^U0} → (^[A] → ^[B]) → ^(List0 [A]) → ^(List0 [B])
  = λ {A}{B} f as. <foldr0 {[A]}{List0 [B]} (λ a bs. cons0 {[B]} [f <a>] bs) (nil0 {[B]}) [as]>;

{-
With inference:
-}

let inlMap0 : {A B : ^U0} → (A → B) → List0 A → List0 B
  = λ f as. foldr0 (λ a bs. cons0 (f a) bs) nil0 as;

{-
Now, inlMap0 always inlines its function argument. Note that inlMap0 can be
used on *any* function argument, but when the function argument is
just a neutral variable (because it's a runtime higher-order function argument),
we don't gain much from inlining a call to that. Examples:
-}

let ex19 : List0 Nat0 → List0 Nat0
  := inlMap0 (comp1 suc0 suc0);
  -- stages to (λ x. foldr0 (λ a bs. cons0 (suc0 (suc0 a)) bs) nil0 x)

let ex20 : (Nat0 → Nat0) → List0 Nat0 → List0 Nat0
  := λ f. inlMap0 f;
  -- in this case, nothing interesting happens, we just inline the "f" variable.
  -- stages to (λ f x. foldr0 (λ a bs. cons0 (f a) bs) nil0 x)

{-
Inlining is one thing, but we can also compute runtime code in more complicated
ways, by recursion or induction on static data. Let's define first some Nat
operations.
-}

let iter0 : {A} → Nat0 → (A → A) → A → A
  := λ {A} n f a. NatElim0 (λ _. A) (λ _. f) a n;

let add0 : Nat0 → Nat0 → Nat0
  := λ a b. iter0 a suc0 b;

let mul0 : Nat0 → Nat0 → Nat0
  := λ a b. iter0 a (add0 b) zero0;

let iter1 : {A} → Nat1 → (A → A) → A → A
  = λ {A} n f a. NatElim1 (λ _. A) (λ _. f) a n;

let add1 : Nat1 → Nat1 → Nat1
  = λ a b. iter1 a suc1 b;

let mul1 : Nat1 → Nat1 → Nat1
  = λ a b. iter1 a (add1 b) zero1;

{-
The "hello world" of staging is some variation of Nat exponentiation, where the
exponent is static. Let's do that. The exponent is the first argument below, to
get more convenient partial applications.
-}

let exp : Nat1 → Nat0 → Nat0
  = λ a b. iter1 a (mul0 b) (suc0 zero0);

let ex21 : Nat0 → Nat0
  := exp (suc1 (suc1 (suc1 zero1)));
  -- stages to (λ x. mul0 x (mul0 x (mul0 x (suc0 zero0))))

{-
That's it for now! There are many more possibilities in 2ltt. You may look at the other
files in this directory for more advanced examples.
-}


U0
