
Staging semantics TODO

Describe basic setup (psh over substitutions and strict (conversion-free) syntax
, types are a constant psh now)

Add identity type, W-type

  - Add to psh model
  - Add to completeness
  - Add to soundness


--------------------------------------------------------------------------------
Random potential citations:

  "kinds are calling conventions"
  ANF translation early paper using CPS gen (citation from "staged selective parser")
  Hinze et al: "theory and practice of fusion"
  GHC call arity paper

--------------------------------------------------------------------------------

Generativity axioms

Yoneda review

(yA → B) ≃ |B|A

to : (yA → B) → |B|A
to f = f A id

from : |B|A → (yA → B)
|from β| X (f : Hom(x, A)) := β[f]

to (from β) = β
(from β) A id = β
(λ X f. β[f]) A id = β
β[id] = β OK

from (to f) = f
from (f A id) = f
λ x g. (f A id)[g] = f
λ x g. (f X (id ∘ g)) = f
λ x g. (f X g) = f
f = f

Constancy
--------------------------------------------------------------------------------

(↑A → K B) ≃ B

f : yA → K B

to show:
∀ X (α α' : Hom(X, A)). |f| X α = |f| X α'
  |f| X α = (|f| A id)[α] = |f| A id = (|f| A id)[α'] = |f| X α'
  OK

More generally:

axiom : Tm (A : Ty, a a' : ↑A, f : ↑A → Ty) (Id (f a) (f a'))

  ∀ Γ. (A : Ty)(a a' : Tm Γ A) (f : ∀ Δ (σ : Sub (Δ,Γ)) → Tm Δ A → Ty) → f Γ id a = f Γ id a'
  f Γ id a =
  f Γ (wkₓ ∘ (id, x ↦ a)) a
  f Γ (wkₓ ∘ (id, x ↦ a))(x[x ↦ a])
  (f (Γ,x) wkₓ x)[x ↦ a]
  (f (Γ,x) wkₓ x)
  f Γ id a' =      similarly
  (f (Γ,x) wkₓ x)

  f Γ id a = f Γ id a' OK

naturality of axiom:
  axiom (stuff[σ]) = (axiom stuff)[σ]  OK because equality is irrelevant

for valTy, if I have f : ↑A → ValTy, then (V ∘ f) : ↑A → Ty is constant by axiom


NOTE :
  generativity axiom is compatible with case on Ty!!!
  everything is compatible with case on Ty!!!


f : yA ⇒ K B     f is constant

f (σ ∘ δ) = f σ

f σ = f (id ∘ σ) = f id = f (id ∘ δ) = f δ OK



axiom : Tm (A : Uₚ, x y : Elₚ A, f : Elₚ A → Ty) (Id (f x) (f y))

f Δ σ x = f Δ' (σ ∘ δ) (x[δ])

f : ∀ Δ (σ : Sub Δ Γ). Tm Δ (Elₚ A) → Ty

f :

f Γ id x = f Γ (p ∘ (id, x)) (q[id, x]) = f (Γ, A) p q

f Γ id x =
f Γ (p ∘ (id, x)) (q[id, x]) =
f (Γ,A) p q =
f Γ (p ∘ (ix, y)

------------------------------------------------------------

y A → F ≃ F(A)

f ↦ f A id
(x : F(A)) ↦ λ B (g : Hom(B, A)). x[g]

f = λ B g. (f A id)[g] = λ B g. f B g   OK
x = (λ B (g : Hom(B, A)). x[g]) A id = x[id] = x OK

if F = const B

f ↦ f A id
b : B ↦ λ _ _. b

f = λ _ _. f A id OK
-- f : yΓ × Tm _ (Elₚ A) → Ty


-- f : y (Γ × Tm (Elₚ A)) → Ty




















------------------------------------------------------------



































-- W-types
--------------------------------------------------------------------------------

- internally to PSh(Obj), we have ordinary W-types, nothing special

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------


- Restricted sup constructor for W:

t : Tm Γ A
u : Tm Γ (B [id, t] ⇒ W A B)

R t : (γ : R Γ) → R A γ

R u γ :
        R (B [id, t] ⇒ W A B) γ
        R ((B ⇒ (W A B)[p])[id, t]) γ
        R (B ⇒ (W A B)[p]) (γ, R t γ)
        R (B ⇒ (W A B)[p]) (γ, R t γ)


R (sup t u) γ : R (W A B) γ



Rapp (R u) γ : (β : R (B[id, t]) γ) → R (W A B) γ
             : (β : R B (γ, R t γ)) → R (W A B) γ

--------------------------------------------------------------------------------

  Rsup : (α : R A γ) → R (B ⇒ W A[p] B[p↑]) (γ, α) → R (W A B) γ
  Rsup (R t γ) (R u γ) = R (sup t u) γ

  define inductively:

      W≈ : Γ≈ γ γ' → W (E A γ) (λ α. E B (γ, α)) → R (W A B) γ' → Set
      sup≈ :   (α : E A γ)
             → (α' : R A γ')
	     → (α≈ : A≈ γ≈ α α')
             → (f  : B (γ, α) → W (E A γ) (E B γ))
	     → (f' : R (B ⇒ W A[p] B[p↑]) (γ', α'))
	     → (f≈ : (B ⇒ W A[p] B[p↑])≈ (γ≈, α≈) f f')           -- this unfolds to taking related inputs to related outputs
	     → (W A B)≈ γ≈ (sup α f) (supR α' f')


  (W A B)≈ γ≈ t t' := W≈ γ≈ t t'

  (sup t u)≈ γ≈ := sup≈ (t≈ γ≈) (u≈ γ≈)


  sup : (a : Tm Γ A) → Tm Γ (B[id,a] ⇒ W A B) → Tm Γ B

  (sup t u)≈ : (γ≈ : Γ≈ γ γ') → W≈ γ≈ (E (sup t u) γ) (R (sup t u) γ')
             : (γ≈ : Γ≈ γ γ') → W≈ γ≈ (sup (E t γ) (E u γ)) (Rsup (R t γ) (R u γ'))

  t≈ γ≈ : A≈ γ≈ (E t γ) (R t γ')
  u≈ γ≈ : (B[id,t] ⇒ W A B)≈ γ≈ (E u γ) (R u γ')

    α≈ OKAY
    need: (B ⇒ (W A B)[p])≈ (γ≈, t≈ γ≈) (E u γ) (R u γ')
        : (b : E B (γ, E t γ))(b' : R B (γ', R t γ'))(b≈ : B≈ (γ≈, t≈ γ≈) b b') → (W A B)≈ γ≈ (E u γ b) (Rapp (R u γ') b')

    have : (B[id,t] ⇒ W A B)≈ γ≈ (E u γ) (R u γ')
         : (b : E (B[id,t]) γ≈)(b' : R (B[id,t]) γ')(b≈ : (B[id,t])≈ γ≈ b b') → (W A B)≈ γ≈ (E u γ b) (RApp (R u γ') b')
	 : (b : E B (γ, E t γ))(b' : R B (γ', R t γ'))(b≈ : B≈ (γ≈ t≈ γ≈) b b') → ...

    OKAY


HOAS restrictions DONT WORK!!!
like "RSup : (a : R A γ) → (R B (γ, a) → R (W A B) γ) → R (W A B) γ "
problem is that we can't create a meta-level fresh var!!

------------------------------------------------------------
W-elimination:
  (P : W A B → Set)
  (∀ a (f : B a → W A B) → (∀ b. P (f b)) → P (sup a f))
  → ∀ w. P w


  E (W-elim P s w) γ := W-elim̂ (λ w. E P (γ, w)) (λ a f g. E s (γ, a, f, g)) (E w γ)


  W-elim : (P : Ty(Γ,W A B)) → Tm (Γ, A, B ⇒ (W A B)[p], Π B[p] (P[p³, app 1 0])) (P[p³, sup 2 1])
                             → (w : Tm Γ (W A B)) → Tm Γ (P[id, w])

  W-elim P s (sup a f) = s[id, a, f, lam (W-elim P[p²,q] s[p] (app (f[p]) 0))]

  (W-elim P s w)≈ γ≈ : (P[id, w])≈ γ≈ (E (W-elim P s w) γ) (R (W-elim P s w) γ')
                     : P≈ (γ≈, w≈ γ≈) (E (W-elim P s w) γ) (R (W-elim P s w) γ')

                     : P≈ (γ≈, w≈ γ≈) (W-elim (λ w. E P (γ, w)) (λ a f g. E s (γ, a, f, g)) (E w γ))
                                      (RW-elim (R (code P) γ') (R s γ') (R w γ'))

                     :=

      w≈ γ≈ : W≈ γ≈ (E w γ) (R w γ')

  (W-elim P s w)≈ γ≈ : (P[id, w])≈ γ≈ (E (W-elim P s w) γ) (R (W-elim P s w) γ')
                     : P≈ (γ≈, w≈ γ≈) (E (W-elim P s w) γ) (R (W-elim P s w) γ')

  W≈-elim (λ w≈. P≈ (γ≈, w≈ γ≈) (E (W-elim P s w) γ) (R (W-elim P s w) γ'))
          (λ α≈ f≈ hyp_f≈ . s≈ (γ≈, α≈, f≈, f≈*))
          (w≈ γ≈)


      -- P≈ (γ≈, sup≈ a≈ f≈) (E (W-elim P s (sup a f)) γ) (R (W-elim P s (sup a f)) γ')
      -- P≈ (γ≈, sup≈ a≈ f≈) (E s (γ, E a γ, E f γ, λ b. W-elim (λ w. E P (γ, w)) (λ a f g. E s (γ, a, f, g)) (E f (γ, b))))
      --                     (R s (γ', R a γ', R f γ', R (lam (W-elim P s (app f 0))) γ'))










Identity type:

    Id t u = (t = u)        equality of sections of presheaves

    refl OK
    UIP OK
    J OK

t : Tm Γ A
E A : E Γ → Set
E t : (γ : E Γ) → E A γ

Soundness:

    (Id t u)≈ : Γ≈ γ γ' → E (Id t u) γ → R (Id t u) γ' → Set
              :         → E t γ = E u γ → R (Id t u) γ' → Set

    (Id t u)≈ γ≈ p p' = (R t γ' = R u γ') × (p' = refl)

    UIP : (p q : Tm Γ (Id t u)) → Tm Γ (Id p q)

    (UIP p q)≈ : (γ≈ : Γ≈ γ γ') → (Id p q)≈ γ≈ (E (UIP p q) γ) (R (UIP p q) γ')
               :                → R p γ' = R q γ'

           have p≈ γ≈ : R t γ' = R u γ' × (R p γ' = refl)
	        q≈ γ≈ : R t γ' = R u γ' × (P q γ' = refl)   OK, but


    transp: Tm Γ (Id t u) → Tm Γ P[id,t] → Tm Γ P[id,u]

    (transp e t)≈ : ∀ γ≈ → P[id,u]≈ γ≈ (E (transp e t) γ) (R (transp e t) γ')
                  :        P≈ (γ≈, u≈ γ≈) (E t γ) (R (transp e t) γ')

        e≈ γ≈ : R t γ' = R u γ' × R e γ' = refl                   -- the refl canonicity thing is required!!

                  :        P≈ (γ≈, u≈ γ≈) (E t γ) (R t γ')
		  OK by t≈ γ≈


    (Id t u)≈ γ≈ p p' = ⊤

    reflect : (t u : Tm Γ A) → Tm Γ (Id t u) → t = u

    (reflect t u p)≈ :     t≈ γ≈ = u≈ γ≈      p : t = u



--------------------------------------------------------------------------------

"unstaging":
  Atsushi Igarashi - he used "unstaging"
  make sure that Atsushi uses it that way

"eval" - a bit confusing
Sheard-Taha shifted away from eval


--------------------------------------------------------------------------------
