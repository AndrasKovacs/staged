
%% build: latexmk -pdf -pvc appendix.tex

\documentclass[acmsmall,screen]{acmart}
%% \raggedbottom

\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column
\pagestyle{plain} % removes running headers
\fancyfoot{}

%% \documentclass[acmsmall]{acmart}
%% \documentclass[nonacm,acmsmall,review]{acmart}
%% \raggedbottom

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.

%% \setcopyright{acmcopyright}
%% \copyrightyear{2018}
%% \acmYear{2018}
%% \acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a JOURNAL article.

%% \acmJournal{JACM}
%% \acmVolume{37}
%% \acmNumber{4}
%% \acmArticle{111}
%% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%% --------------------------------------------------------------------------------

\usepackage{xcolor}
\usepackage{mathpartir}
\usepackage{todonotes}
\presetkeys{todonotes}{inline}{}
\usepackage{scalerel}
\usepackage{bm}
%% \usepackage{amssymb}

\newcommand{\mit}[1]{\mathit{#1}}
\newcommand{\msf}[1]{\mathsf{#1}}
\newcommand{\mbb}[1]{\mathbb{#1}}
\newcommand{\mbf}[1]{\mathbf{#1}}
\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\ext}{\triangleright}
\newcommand{\Code}{\msf{Code}}
\newcommand{\El}{\msf{El}}
\newcommand{\lam}{\msf{lam}}
\newcommand{\app}{\msf{app}}
\newcommand{\NatElim}{\msf{NatElim}}
\newcommand{\y}{\msf{y}}

\newcommand{\Lift}{{\Uparrow}}
\newcommand{\spl}{{\sim}}
\newcommand{\qut}[1]{\langle #1\rangle}

\newcommand{\mbbc}{\mbb{C}}
\newcommand{\mbbo}{\mbb{O}}
\newcommand{\ob}{_\mbbo}

\renewcommand{\U}{\msf{U}}
\newcommand{\Con}{\msf{Con}}
\newcommand{\Sub}{\msf{Sub}}
\newcommand{\Ty}{\msf{Ty}}
\newcommand{\Tm}{\msf{Tm}}
\newcommand{\Cono}{\msf{Con}_{\mbbo}}
\newcommand{\Subo}{\msf{Sub}_{\mbbo}}
\newcommand{\Tyo}{\msf{Ty}_{\mbbo}}
\newcommand{\Tmo}{\msf{Tm}_{\mbbo}}
\newcommand{\hCon}{\wh{\msf{Con}}}
\newcommand{\hSub}{\wh{\msf{Sub}}}
\newcommand{\hTy}{\wh{\msf{Ty}}}
\newcommand{\hTm}{\wh{\msf{Tm}}}

\newcommand{\p}{\mathsf{p}}
\newcommand{\q}{\mathsf{q}}

\newcommand{\refl}{\msf{refl}}
\newcommand{\Bool}{\msf{Bool}}
\newcommand{\true}{\msf{true}}
\newcommand{\false}{\msf{false}}
\newcommand{\True}{\msf{True}}
\newcommand{\False}{\msf{False}}
\newcommand{\List}{\msf{List}}
\newcommand{\nil}{\msf{nil}}
\newcommand{\cons}{\msf{cons}}
\newcommand{\Nat}{\msf{Nat}}
\newcommand{\zero}{\msf{zero}}
\newcommand{\suc}{\msf{suc}}
\renewcommand{\tt}{\msf{tt}}
\newcommand{\fst}{\msf{fst}}
\newcommand{\snd}{\msf{snd}}
\newcommand{\mylet}{\msf{let}}
\newcommand{\emptycon}{\scaleobj{.75}\bullet}
\newcommand{\id}{\msf{id}}

\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Prop}{\mathsf{Prop}}
\newcommand{\Rep}{\msf{Rep}}
\newcommand{\blank}{{\mathord{\hspace{1pt}\text{--}\hspace{1pt}}}}
\newcommand{\emb}[1]{\ulcorner#1\urcorner}

\newcommand{\Stage}{\msf{Stage}}
\newcommand{\hato}{\bm\hat{\mbbo}}
\newcommand{\ev}{\mbb{E}}
\newcommand{\re}{\mbb{R}}

\theoremstyle{remark}
\newtheorem{notation}{Notation}

\newcommand{\whset}{\wh{\Set}}
\newcommand{\rexti}{\re_{\ext_1}^{-1}}
\newcommand{\rextizero}{\re_{\ext_0}^{-1}}

\newcommand{\rel}{^{\approx}}
\newcommand{\yon}{\msf{y}}


%% --------------------------------------------------------------------------------

%%
%% end of the preamble, start of the body of the document source.
%% \hypersetup{draft}
\begin{document}

\title{Staged Compilation With Two-Level Type Theory (Appendix)}

%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{András Kovács}
\email{kovacsandras@inf.elte.hu}
\orcid{0000-0002-6375-9781}
\affiliation{%
  \institution{Eötvös Loránd University}
  \country{Hungary}
  \city{Budapest}
}

\maketitle

In this appendix, we give two complete specifications of models of 2LTT,
one in the style of derivation rules, and one as a second-order algebraic
signature.

\section{A Rule-Based Presentation of 2LTT}\label{sec:rules}

In this section, we give a rule-based description of the notion of model of
2LTT. This is the same as what is described in Section 3.3 of the paper, but
presented in a way which is closer to the conventional rule-based specification
of lambda calculi.

Note that we do not only specify the notion of \emph{syntax} for the theory, but
more generally the notion of \emph{model}, because the rules constitute a
signature for an algebraic theory. We do a small warmup example first.

\subsection{Warmup: Signature for Monoids}

The theory of monoids is a simple example of an algebraic theory. We can write the
following signature. We implicitly universally quantify over the $x,y,z$ variables.
\begin{alignat*}{3}
  & C &&: \Set \\
  & \blank\!+\blank\! &&: C \to C \to C\\
  & \mit{e} &&: C \\
  & \msf{id_l} &&: \mit{e} + x = x\\
  & \msf{id_r} &&: x + \mit{e} = x\\
  & \msf{assoc} &&: x + (y + z) = (x + y) + z\\
\end{alignat*}
A model of the theory of monoids is just a monoid: a set $C$ together with an
associative operation and an identity element. The initial monoid is the trivial
monoid which has only $\mit{e}$ in the underlying set. We can rephrase the above
signature using judgments and rules:

\begin{alignat*}{2}
  & \boxed{x\vdash}\hspace{3em}  && \text{\emph{means $x : C$}}\\
  & \boxed{x = y \vdash}         && \text{\emph{means $x = y$ assuming $x : C$ and $y : C$}}
\end{alignat*}

\begin{mathpar}
  \inferrule*[lab=op]
             {x \vdash \\ y \vdash}
             {x + y \vdash}

  \inferrule*[lab=identity]
             {\\}
             {\mit{e} \vdash}

  \inferrule*[lab=left-identity]
             {x \vdash}
             {\mit{e} + x = x \vdash}

  \inferrule*[lab=right-identity]
             {x \vdash}
             {x + \mit{e} = x \vdash}

  \inferrule*[lab=associativity]
             {x \vdash \\ y \vdash \\ z \vdash}
             {x + (y + z) = (x + y) + z \vdash}
\end{mathpar}

Additionally, we assume that $\blank\!=\blank\!\vdash$ behaves as metatheoretic
equality: it is an equivalence, it is respected by all rules and constructions,
and we can freely replace $x$ with $y$ whenever $x = y\vdash$ is derivable.

Here, the derivation rule notation is a bit peculiar and verbose. But note that
the same phenomenon happens in the specification of type theories, where the
``signature'' notation is much more compact than the derivation rule
notation. As far as the author of this work sees, this is a strong motivation
for generally moving away from derivation rule notations in the metatheory of
type theories. This is regardless whether we specify conversion using
metatheoretic equality or using explicit relations; recall Section 3.3.3 in the
paper where the latter style is sketched.

Nevertheless, the mental switch from rule-based presentation to algebraic
signatures is not a trivial task, so in the following we present the signature
for 2LTT using derivation rules.

\subsection{Judgments of 2LTT}

First we look at the judgments. Below, and in all following rules in this
section, we assume that $i \in \{0,1\}$ and $j \in \mathbb{N}$. We use $\Gamma,\Delta$ to
refer to contexts, $\sigma,\delta$ for substitutions, $A,B,C$ for types and $t,u,v$ for terms.

\begin{alignat*}{2}
  & \boxed{\Gamma\vdash}\hspace{6em}           && \text{\emph{context formation}}\\
  & \boxed{\Gamma\vdash \sigma : \Delta}       && \text{\emph{explicit substitution formation, assuming $\Gamma \vdash$ and $\Delta \vdash$}}\\
  & \boxed{\Gamma \vdash \sigma = \delta : \Delta} && \text{\emph{substitution equality, assuming $\Gamma \vdash \sigma : \Delta$ and $\Gamma \vdash \delta : \Delta$}}\\
  & \boxed{\Gamma\vdash_{i,j} A}                && \text{\emph{type formation, assuming $\Gamma\vdash$}}\\
  & \boxed{\Gamma\vdash_{i,j} t : A}            && \text{\emph{term formation, assuming $\Gamma \vdash_{i,j} A$}}\\
  & \boxed{\Gamma \vdash_{i,j} A = B}           && \text{\emph{type equality, assuming $\Gamma \vdash_{i,j} A$ and $\Gamma \vdash_{i,j} B$}}\\
  & \boxed{\Gamma \vdash_{i,j} t = u : A}       && \text{\emph{term equality, assuming $\Gamma \vdash_{i,j} t : A$ and $\Gamma \vdash_{i,j} u : A$}}
\end{alignat*}
\newline
\noindent The judgments correspond to the prefix of the signature which specifies the underlying sets (``sorts''). If equality judgments are identified with metatheoretic equality, that is automatically available, so we do not have to introduce them in the signature.

\begin{alignat*}{2}
  & \Con &&: \Set \\
  & \Sub &&: \Con \to \Con \to \Set \\
  & \Ty_{i,j}  &&: \Con \to \Set \\
  & \Tm_{i,j}  &&: (\Gamma : \Con) \to \Ty_{i,j}\,\Gamma \to \Set
\end{alignat*}

In the following we only present the rule-based specification. We will
often omit assumptions from rules which are implied from other judgments. For
example, if $\Gamma \vdash_{i,j} A$ is assumed, we can omit $\Gamma \vdash$.

\subsection{Core Substitution Calculus}
\vspace{1em}

\begin{mathparpagebreakable}

  \inferrule*[lab=empty-cxt]
             {\\}
             {\emptycon \vdash}

  \inferrule*[lab=cxt-extension]
             {\Gamma \vdash \\ \Gamma \vdash_{i,j} A}
             {\Gamma \ext A \vdash}

  \inferrule*[lab=identity-sub]
             {\Gamma \vdash}
             {\Gamma \vdash \id : \Gamma}

  \inferrule*[lab=sub-composition]
             {\Delta \vdash \sigma : \Theta \\ \Gamma \vdash \delta : \Delta}
             {\Gamma \vdash \sigma \circ \delta : \Theta}

  \inferrule*[lab=empty-sub]
             {\Gamma \vdash}
             {\Gamma \vdash \epsilon : \emptycon}

  \inferrule*[lab=empty-sub-$\eta$]
             {\Gamma \vdash \sigma : \emptycon}
             {\Gamma \vdash \sigma = \epsilon : \emptycon}

  \inferrule*[lab=id-left]
             {\Gamma \vdash \sigma : \Delta}
             {\Gamma : \id \circ \sigma = \sigma : \Delta}

  \inferrule*[lab=id-right]
             {\Gamma \vdash \sigma : \Delta}
             {\Gamma : \sigma \circ \id = \sigma : \Delta}

  \inferrule*[lab=comp-assoc]
             {\Theta \vdash \sigma : \Xi \\ \Delta \vdash \delta : \Theta \\ \Gamma \vdash \sigma : \Delta}
             {\Gamma : \sigma \circ (\delta \circ \nu) = (\sigma \circ \delta) \circ \nu : \Xi}

  \inferrule*[lab=type-sub]
             {\Delta \vdash_{i,j} A \\ \Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,j} A[\sigma]}

  \inferrule*[lab=term-sub]
             {\Delta \vdash_{i,j} t : A \\ \Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,j} t[\sigma] : A[\sigma]}

  \inferrule*[lab=type-id-sub]
             {\Gamma \vdash_{i,j} A}
             {\Gamma \vdash_{i,j} A[\id] = A}

  \inferrule*[lab=term-id-sub]
             {\Gamma \vdash_{i,j} t : A}
             {\Gamma \vdash_{i,j} t[\id] = t : A}

  \inferrule*[lab=type-comp-sub]
             {\Theta \vdash_{i,j} A \\ \Delta \vdash \delta : \Theta \\ \Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,j} A[\sigma \circ \delta] = A[\sigma][\delta]}

  \inferrule*[lab=term-comp-sub]
             {\Theta \vdash_{i,j} t : A \\ \Delta \vdash \delta : \Theta \\ \Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,j} t[\sigma \circ \delta] = t[\sigma][\delta] : A[\sigma][\delta]}

  \inferrule*[lab=sub-extension]
             {\Gamma \vdash \sigma : \Delta \\ \Gamma \vdash t : A[\sigma]}
             {\Gamma \vdash (\sigma,\,t) : \Delta \ext A}

  \inferrule*[lab=sub-first-proj]
             {\Gamma \vdash_{i,j} A}
             {\Gamma \ext A \vdash \p : \Gamma}

  \inferrule*[lab=sub-second-proj]
             {\Gamma \vdash _{i,j} A}
             {\Gamma \ext A \vdash \q : A[\p]}

  \inferrule*[lab=$\p$-$\beta$]
             {\Gamma \vdash \sigma : \Delta \\ \Gamma \vdash_{i,j} t : A[\sigma]}
             {\Gamma \vdash \p \circ (\sigma,\,t) = \sigma : \Delta}

  \inferrule*[lab=$\q$-$\beta$]
             {\Gamma \vdash \sigma : \Delta \\ \Gamma \vdash_{i,j} t : A[\sigma]}
             {\Gamma \vdash_{i,j} \q [\sigma,\,t] = t : A[\sigma]}

  \inferrule*[lab=sub-extension-$\eta$]
             {\\}
             {\Gamma \vdash (\p,\,\q) = \id : \Gamma}

  \inferrule*[lab=sub-extension-$\circ$]
             {\Delta \vdash \sigma : \Theta \\ \Delta \vdash_{i,j} t : A[\sigma] \\ \Gamma \vdash \delta : \Delta}
             {\Gamma \vdash (\sigma,\,t) \circ \delta = (\sigma \circ \delta,\,t[\delta]) : \Theta \ext A}
\end{mathparpagebreakable}

As we noted in Definition 3.2 in the paper, we recover De Bruijn indices in the following way: the
$n$-th index is $\q[\p^{n}]$, where $\p^{n}$ is the $n$-fold composition of $\p$ (0-fold composition is $\id$).

\subsection{Lifting Structure}

\begin{mathparpagebreakable}

  \inferrule*[lab=lift]
             {\Gamma \vdash_{0,j} A}
             {\Gamma \vdash_{1,j} \Lift A}

  \inferrule*[lab=lift-sub]
             {\Gamma \vdash \sigma : \Delta \\ \Delta \vdash_{0,j} A}
             {\Gamma \vdash_{1,j} (\Lift A)[\sigma] = \Lift(A[\sigma])}

  \inferrule*[lab=quote]
             {\Gamma \vdash_{0,j} t : A}
             {\Gamma \vdash_{1,j} \qut{t} : \Lift A}

  \inferrule*[lab=quote-sub]
             {\Delta \vdash_{0,j} t : A \\ \Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{1,j} \qut{t}[\sigma] = \qut{t[\sigma]} : \Lift (A[\sigma])}

  \inferrule*[lab=splice]
             {\Gamma \vdash_{1,j} t : \Lift A}
             {\Gamma \vdash_{0,j} \spl{t} : A}

  \inferrule*[lab=quote-splice]
             {\Gamma \vdash_{1,j} t : \Lift A}
             {\Gamma \vdash_{1,j} \qut{\spl{t}} = t : \Lift A}

  \inferrule*[lab=splice-quote]
             {\Gamma \vdash_{0,j} t : A}
             {\Gamma \vdash_{0,j} \spl{\qut{t}} = t : A}

\end{mathparpagebreakable}

Here, note that the substitution rule for splicing is omitted, because it can be
derived from the fact that splicing is a bijection; in other words, if one
component map of an isomorphism is natural, so is the other map.

\subsection{Universes}
\vspace{1em}

\begin{mathparpagebreakable}

  \inferrule*[lab=universe]
             {\\}
             {\Gamma \vdash_{i,j+1} \U_j}

  \inferrule*[lab=universe-sub]
             {\Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,j+1} \U_j[\sigma] = \U_j}

  \inferrule*[lab=universe-decoding]
             {\Gamma \vdash_{i,j+1} t : \U_j}
             {\Gamma \vdash_{i,j} \El\,t}

  \inferrule*[lab=decoding-sub]
             {\Gamma \vdash \sigma : \Delta \\ \Delta \vdash_{i,j+1} t : \U_j}
             {\Gamma \vdash_{i,j} (\El\,t)[\sigma] = \El(t[\sigma])}

  \inferrule*[lab=universe-encoding]
             {\Gamma \vdash_{i,j} A}
             {\Gamma \vdash_{i,j+1} \Code\,A : \U_j}

  \inferrule*[lab=decoding-encoding]
             {\Gamma \vdash_{i,j} A}
             {\Gamma \vdash_{i,j} \El\,(\Code\,A) = A}

  \inferrule*[lab=encoding-decoding]
             {\Gamma \vdash_{i,j+1} t : \U_j}
             {\Gamma \vdash_{i,j+1} \Code\,(\El\,t) = t : \U_j}

\end{mathparpagebreakable}

\subsection{$\Sigma$-types}
\vspace{1em}

\begin{mathparpagebreakable}

  \inferrule*[lab=$\Sigma$-formation]
             {\Gamma \vdash_{i,j} A \\ \Gamma \ext A \vdash_{i,j} B}
             {\Gamma \vdash_{i,j} \Sigma\,A\,B}

  \inferrule*[lab=$\Sigma$-sub]
             {\Gamma \vdash \sigma : \Delta \\ \Delta \vdash_{i,j} A \\ \Delta \ext A \vdash_{i,j} B}
             {\Gamma \vdash_{i,j} (\Sigma\,A\,B)[\sigma] = \Sigma\,(A[\sigma])\,(B[\sigma\circ\p,\,\q])}

  \inferrule*[lab=pairing]
             {\Gamma \vdash_{i,j} t : A \\ \Gamma \vdash_{i,j} u : B[\id,\,t]}
             {\Gamma \vdash_{i,j} (t,\,u) : \Sigma\,A\,B}

  \inferrule*[lab=pairing-sub]
             {\Gamma \vdash \sigma : \Delta \\ \Delta \vdash_{i,j} t : A \\ \Delta \vdash_{i,j} u : B[\id,\,t]}
             {\Gamma \vdash_{i,j} (t,\,u)[\sigma] = (t[\sigma],\,u[\sigma]) : \Sigma\,(A[\sigma])\,(B[\sigma\circ\p,\,\q])}

  \inferrule*[lab=fst]
             {\Gamma \vdash_{i,j} t : \Sigma\,A\,B}
             {\Gamma \vdash_{i,j} \fst\,t : A}

  \inferrule*[lab=snd]
             {\Gamma \vdash_{i,j} t : \Sigma\,A\,B}
             {\Gamma \vdash_{i,j} \snd\,t : B[\id,\,\fst\,t]}

  \inferrule*[lab=fst-$\beta$]
             {\Gamma \vdash_{i,j} t : A \\ \Gamma \vdash_{i,j} u : B[\id,\,t]}
             {\Gamma \vdash_{i,j} \fst\,(t,\,u) = t : A}

  \inferrule*[lab=snd-$\beta$]
             {\Gamma \vdash_{i,j} t : A \\ \Gamma \vdash_{i,j} u : B[\id,\,t]}
             {\Gamma \vdash_{i,j} \snd\,(t,\,u) = u : B[\id,\,t]}

  \inferrule*[lab=$\Sigma$-$\eta$]
             {\Gamma \vdash_{i,j} t : \Sigma\,A\,B}
             {\Gamma \vdash_{i,j} (\fst\,t,\,\snd\,t) = t : \Sigma\,A\,B}

\end{mathparpagebreakable}

\subsection{$\Pi$-types}
\vspace{1em}

\begin{mathparpagebreakable}

  \inferrule*[lab=$\Pi$-formation]
             {\Gamma \vdash_{i,j} A \\ \Gamma \ext A \vdash_{i,j} B}
             {\Gamma \vdash_{i,j} \Pi\,A\,B}

  \inferrule*[lab=$\Pi$-sub]
             {\Gamma \vdash \sigma : \Delta \\ \Delta \vdash_{i,j} A \\ \Delta \ext A \vdash_{i,j} B}
             {\Gamma \vdash_{i,j} (\Pi\,A\,B)[\sigma] = \Pi\,(A[\sigma])\,(B[\sigma\circ\p,\,\q])}

  \inferrule*[lab=lam]
             {\Gamma \ext A \vdash_{i,j} t : B}
             {\Gamma \vdash_{i,j} \lam\,t : \Pi\,A\,B}

  \inferrule*[lab=lam-sub]
             {\Gamma \vdash \sigma : \Delta \\ \Delta \ext A \vdash_{i,j} t : B}
             {\Gamma \vdash_{i,j} (\lam\,t)[\sigma] = \lam\,(t[\sigma\circ\p,\,\q]) : \Pi\,(A[\sigma])\,(B[\sigma\circ\p,\,\q])}

  \inferrule*[lab=app-lam]
             {\Gamma \ext A \vdash_{i,j} t : B}
             {\Gamma \ext A \vdash_{i,j} \app\,(\lam\,t) = t : B}

  \inferrule*[lab=lam-app]
             {\Gamma \vdash_{i,j} t : \Pi\,A\,B}
             {\Gamma \vdash_{i,j} \lam\,(\app\,t) = t : \Pi\,A\,B}

\end{mathparpagebreakable}
\vspace{1em}

Like before, for universes, $\Sigma$-types and $\Pi$-types, it is enough to specify
substitution rules in one direction of isomorphisms.

\subsection{Natural Numbers}
\vspace{1em}

\begin{mathparpagebreakable}

  \inferrule*[lab=nat-formation]
             {\\}
             {\Gamma \vdash_{i,j} \Nat}

  \inferrule*[lab=nat-sub]
             {\Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,j} \Nat[\sigma] = \Nat}

  \inferrule*[lab=zero]
             {\\}
             {\Gamma \vdash_{i,j} \zero : \Nat}

  \inferrule*[lab=zero-sub]
             {\Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,j} \zero[\sigma] = \zero : \Nat}

  \inferrule*[lab=suc]
             {\Gamma \vdash_{i,j} t : \Nat}
             {\Gamma \vdash_{i,j} \suc\,t : \Nat}

  \inferrule*[lab=suc-sub]
             {\Gamma \vdash \sigma : \Delta \\ \Delta \vdash_{i,j} t : \Nat}
             {\Gamma \vdash_{i,j} (\suc\,t)[\sigma] = \suc\,(t[\sigma]) : \Nat}

  \inferrule*[lab=nat-elim]
             {\Gamma \ext \Nat \vdash_{i,k} P \\\\
              \Gamma \vdash_{i,k} z : P[\id,\,\zero] \\\\
              \Gamma \ext \Nat \ext P \vdash_{i,k} s : P[\p\circ\p,\,\suc\,(\q[\p])] \\\\
              \Gamma \vdash_{i,j} t : \Nat
             }
             {\Gamma \vdash_{i,k} \msf{NatElim}\,P\,z\,s\,t : P[\id,\,t]}

  \inferrule*[lab=nat-elim-sub]
             {\Gamma \vdash \sigma : \Delta}
             {\Gamma \vdash_{i,k} (\msf{NatElim}\,P\,z\,s\,t)[\sigma] = \\\\
               \msf{NatElim}\,(P[\sigma\circ\p,\,q])\,(z[\sigma])\,(s[\sigma\circ\p\circ\p,\,\q[\p],\,\q])\,(t[\sigma]): P[\sigma,\,t[\sigma]]}

  \inferrule*[lab=zero-$\beta$]
             {\\}
             {\Gamma \vdash_{i,j} \msf{NatElim}\,P\,z\,s\,\zero = z : P[\id,\,\zero]}

  \inferrule*[lab=suc-$\beta$]
             {\\}
             {\Gamma \vdash_{i,j} \msf{NatElim}\,P\,z\,s\,(\suc\,t) = s[\id,\,t,\,\msf{NatElim}\,P\,z\,s\,t]
               : P[\id,\,\suc\,t]}
\end{mathparpagebreakable}

\section{A Second-Order Algebraic Signature for 2LTT}

The presentation in the previous section was still quite verbose; although note
that it is a \emph{complete} set of rules. Using explicit conversion relations
the number of rules would increase greatly, because we would need to specify the
congruence closure rules and the coercion/coherence rules everywhere.

A signature-style presentation is more concise the above rule-based one, but we
can do even better. There is a style of specification which dramatically reduces
the boilerplate, based on the following observations:
\begin{itemize}
  \item Everything must be stable under substitution.
  \item Contexts are threaded through rules in a mechanical way.
\end{itemize}
This might be familiar from the semantics of 2LTT itself: by working in the
internal language of presheaves over a category of contexts, we can entirely
skip talking about contexts and substitution rules. This is a \emph{higher-order
abstract syntax} presentation, alternatively called a \emph{logical framework}
\cite{DBLP:journals/jacm/HarperHP93} presentation. In this specific case, 2LTT
has a \emph{second-order} signature, which means that rules can have assumptions
which themselves universally quantify over terms.

In the following we present such a signature. We will not detail the syntax and
the semantics; the syntax of the signature below is meant to be a variation on
Uemura's second-order signatures for representable map categories
\cite{uemura}. As additional notation, we write isomorphisms as $(f,\,g) : A
\simeq B$, where $f : A \to B$ with inverse $g$.

\begingroup
\allowdisplaybreaks
\begin{alignat*}{5}
  &\Ty_{i,j} &&: \Set\\
  &\Tm_{i,j} &&: \Ty_{i,j} \to \Set^{\msf{rep}} \\
  &\Lift    &&: \Ty_{0,j} \to \Ty_{1,j} \\
  &(\qut{\blank},\,\spl{\blank}) &&: \Tm_{0,j}\,A \simeq \Tm_{1,j}\,(\Lift A)\\
  &\U_j     &&: \Ty_{i,j+1}\\
  &(\El,\,\Code) &&: \Tm_{i,j+1}\,\U_j \simeq \Ty_{i,j}\\
  & \Sigma &&: (A : \Ty_{i,j}) \to (\Tm_{i,j}\,A \to \Ty_{i,j}) \to \Ty_{i,j} \\
  &(\msf{proj},\,(\blank\!,\!\blank)) &&: \Tm_{i,j}\,(\Sigma\,A\,B) \simeq ((t : \Tm_{i,j}\,A) \times \Tm_{i,j}\,(B\,t))\\
  &\Pi &&: (A : \Ty_{i,j}) \to (\Tm_{i,j}\,A \to \Ty_{i,j}) \to \Ty_{i,j}\\
  &(\app,\,\lam) &&: \Tm_{i,j}\,(\Pi\,A\,B) \simeq ((t : \Tm_{i,j}\,A) \to \Tm_{i,j}\,(B\,t))\\
  &\Nat &&: \Ty_{i,j} \\
  &\zero &&: \Tm_{i,j}\,\Nat \\
  &\suc  &&: \Tm_{i,j}\,\Nat \to \Tm_{i,j}\,\Nat \\
  &\msf{NatElim} &&: (P : \Tm_{i,j}\,\Nat \to \Ty_{i,k}) \to \Tm_{i,k}\,(P\,\zero) \\
  & && \hspace{0.8em}\to ((n : \Tm_{i,j}\,\Nat) \to \Tm_{i,k}\,(P\,n) \to \Tm_{i,j}\,(P\,(\suc\,n))) \\
  & && \hspace{0.8em}\to (n : \Tm_{i,j}\,\Nat) \to \Tm_{i,k}\,(P\,n)\\
  & \zero\beta &&: \msf{NatElim}\,P\,z\,s\,\zero = z \\
  & \suc\beta  &&: \msf{NatElim}\,P\,z\,s\,(\suc\,n) = s\,n\,(\msf{NatElim}\,P\,z\,s\,n)
\end{alignat*}
\endgroup
Note the $\Set^{\msf{rep}}$ in the return type of $\Tm_{i,j}$ above. This marks
the sort of terms as being \emph{locally representable}: this means that we can use
second-order quantification over terms, for instance in the specification of $\Pi$.

Remarkably, the above signature can be mechanically translated to the verbose
rule set. Informally, the signature is interpreted in presheaves over an
implicit underlying category of contexts, so that we recover a naturality
condition for each rule, corresponding to the substitution rule. Abstraction
over locally representable sorts is interpreted as context extension. For
instance, the second-order function space $\Tm_{i,j}\,A \to \Ty_{i,j}$ in the
type of $\Pi$ is translated to a set of types in a context extended with $A$.

\bibliographystyle{ACM-Reference-Format}
\interlinepenalty=10000
\bibliography{references}

\end{document}
\endinput
