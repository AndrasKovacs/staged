


-- Gen : U → U
--    = λ A. {R : U} → (A → □ R) → □ R;

-- ret : {A} → A → Gen A
--   = λ a k. k a;

-- bind : {A B} → Gen A → (A → Gen B) → Gen B
--   = λ ga f k. ga λ a. (f a) k;

-- runGen : {A} → Gen (□ A) → □ A
--   = λ ga. ga (λ x. x);

-- ℕ : U
--    = (N : U) → (N → N) → N → N;

-- zero  : ℕ = λ _ s z. z;
-- suc   : ℕ → ℕ = λ n N s z. s (n N s z);

-- iter  : {A} → ℕ → (A → A) → A → A
--   = λ n s z. n _ s z;

-- add : ℕ → ℕ → ℕ
--   = λ a b N s z. a N s (b N s z);

-- mul : ℕ → ℕ → ℕ
--   = λ a b N s z. a N (b N s) z;

-- n0   = zero;
-- n1   = suc zero;
-- n2   = suc $ suc zero;
-- n3   = suc $ suc $ suc zero;
-- n5   = suc $ suc $ suc $ suc $ suc zero;
-- n10  = add n5 n5;
-- n100 = mul n10 n10;
-- n1k  = mul n100 n10;
-- n10k = mul n100 n100;

-- mkExp : ℕ → □ (ℕ → ℕ)
--   = λ x. <λ y. ~(x _ (λ f. <mul ~f y>) <n1>)>;

-- exp5 = ~(mkExp n5);

-- return exp5




-- let List : U → U =
--   λ A. (L : U) → (A → L → L) → L → L;

-- let nil : {A} → List A =
--   λ L c n. n;

-- let cons : {A} → A → List A → List A =
--   λ a as L c n. c a (as L c n);

-- do ref ← new (nil {⊤});

-- do write ref (cons tt nil);

-- let id : {A} → □ A → □ A =
--   λ x. x;

let majom : Eff (⊤ → ⊤) =
  do x ← return (λ (y : ⊤). y);
  let kek =
    let bar =
      (λ (y : ⊤). y);
    bar;
  return kek;

return tt

-- return (cons tt (cons tt (cons tt nil)))
