
Simple ADTs:

data List (A : VTy) = Nil | Cons A (List A)

- params must be params (uniform), no nested induction
- every field type must be in VTy

- derived constructor types:
  Nil  : {A : VTy} → ^(List A)
  Cons : {A : VTy} → ^A → ^(List A)

scheme :

   T (φ : Δ) = D₀ F₀ⱼ | ... | Dᵢ Fᵢⱼ

   Δ : Tel
   φ : Δ ⊢ Fᵢⱼ : VTy
   ∀ σ. (T σ ∈ Fᵢⱼ) → (σ = φ)

constructor types:

   T  : Δ → VTy
   Dᵢ : {φ : Δ} → ^(Fᵢⱼ) → ^(T φ)

case expressions:

  Γ ⊢ t : T φ    Γ ⊢ Dᵢ constructor of T     Γ ⊢ R :
  Γ, σ : Fᵢⱼ[φ ↦ φ] ⊢ rhsᵢ : R
  ──────────────────────────────────────────────────────────────
              Γ ⊢ case t of Dᵢ σ → rhsᵢ : R


------------------------------------------------------------

Features planned before self-host

  - single-threaded RTS, compile to LLVM
  - staging with caching
  - side effects, without monad
  - exceptions (DIY sjlj, globally unique symbols for each thrown type)
  - C FFI, + Rust if possible
  - mutual blocks with forward declaration
  - mutual ADTs, possibly also with forward declaration
  - nested/multiple case expression compilation
  - some way to write generic programs with Object type
    (e.g. equality, hashing, serialization)
    first version: Object, generic Box type + unsafeCoerce
  - stack Ref type
  - pinned arrays, unsafe ptr borrowing from them
  - projection-like overloading for ADTs and newtypes
  - unboxed sums

  debug
  - traceback in debug mode
  - debug printing functions with access to traceback
  - elaboration-time debug functions in surface syntax: print stuff, measure time
    - (another stage for elab-time programming?)

  optional
  - CPS subtyping for ADTs
  - Closure type
