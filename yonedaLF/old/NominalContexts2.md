# Nameful contextual notation for embedded theories

Nameful notation for binders is universally used in practical programming languages and mathematical
notation. But if we want to formalize stuff about a language that's deeply embedded in some
metatheory, the picture is not so clear.

- Higher-order abstract syntax (HOAS) is great when it works, but it's not always
  applicable. Syntactic translations or model constructions that do fancy things with contexts are
  often not expressible in HOAS frameworks. For example
  - CPS, ANF translation
  - Closure conversion
  - Many optimizations, like dead code elimination
  - Some parametricity translations

- Named variables have been used in numerous papers, but often in an uncomfortably fuzzy way, with a
  lot of implicitly assumed formal boilerplate.

I propose a nameful notation for embedded theories, which can be straightforwardly desugared into
some algebraic/categorical calculus. Benefits:

- It's a lot more readable than nameless notation.
- We can do complete equational reasoning on the nameful notation, IMO more easily than on the
  nameless one.
- We can use the notation very generally, whenever we have a well-behaved notion of "context" and
  "substitution". It certainly works for first-order models of any second-order algebraic theory.

Here I'm focusing on using the notation in pen-and-paper formalization. Supporting it in proof
assistants would be nice too, but it'd take more thought and more work.

## Setup (categories with families)

I'm taking categories-with-families (CwF) as my specification of contexts and substitutions, but you
can swap it out to any other equivalent setup.

Let's recap CwFs. A CwF has the following underlying sets:

    Con : Set                      -- context
	Sub : Con → Con → Set          -- substitution
	Ty  : Con → Set                -- type
	Tm  : (Γ : Con) → Ty Γ → Set   -- term

I'll write Γ, Δ, Ξ for contexts, σ, δ, ν for substitutions, A, B, C for types and t, u, v for terms.

Parallel substitutions (Sub) form a category, with the empty context ∙ being the terminal object.

    _∘_ : Sub Δ Ξ → Sub Γ Δ → Sub Γ Ξ
	id  : Sub Γ Γ
	_   : id ∘ σ = σ
	_   : σ ∘ id = σ
	_   : (σ ∘ δ) ∘ ν = σ ∘ (δ ∘ ν)
	∙   : Con
	()  : Sub Γ ∙
	_   : (σ : Sub Γ ∙) → σ = ()

A parallel substitution (σ : Sub Γ Δ) is, intuitively, a list of Δ-many terms where each term is in
context Γ. The empty substitution () is an empty list of terms; we'll look at non-empty
substitutions shortly. Terms and types can be substituted:

    _[_] : Ty Δ → Sub Γ Δ → Ty Γ
	_[_] : Tm Δ A → (σ : Sub Γ Δ) → Tm Γ (A[σ])

Substitution is functorial for types and terms:

    A[id]    = t
	A[σ ∘ δ] = A[σ][δ]
    t[id]    = t
	t[σ ∘ δ] = t[σ][δ]

Contexts can be extended:

    _,_ : (Γ : Con) → Ty Γ → Con

We can build substitutions ("cons" our lists) as follows:

    _,_ : (σ : Sub Γ Δ) → Tm Γ (A[σ]) → Sub Γ (Δ,A)
	fst : Sub Γ (Δ,A) → Sub Γ Δ
	snd : (σ : Sub Γ (Δ,A)) → Tm Γ (A[fst σ])
	_   : (fst σ, snd σ) = σ
	_   : fst (σ, t) = σ
	_   : snd (σ, t) = t
	_   : (σ, t) ∘ δ = (σ ∘ δ, t[δ])

That's it for CwFs.

We make some derived definitions. The *weakening substitution* drops the last entry from a context:

    wk : Sub (Γ, A) Γ
	wk := fst (id {Γ,A})

Here, id {Γ,A} : Sub (Γ,A) (Γ,A), and the curly braces are meant to be an Agda-like implicit
argument notation.

The *zero De Bruijn index* is the variable pointing to the last context entry:

    0 : Tm (Γ,A) (A[wk])
	0 := snd (id {Γ,A})

We can define every other De Bruijn index as iterated weakening of zero, so that the index "n" is
zero[wkⁿ], where wkⁿ is the n-fold composition of wk.

A CwF is perhaps not too simple, but it is a whole lot simpler than building up the specification
for some theory starting from untyped terms. The syntax of some theory is obtained when we consider
the specification as a *quotient inductive-inductive definition*, where everything is freely
generated by the operations and quotiented by the equations.

If for some reason we start from untyped terms, we can still show that the syntax and substitutions
that we defined can be arranged into a CwF, when appropriately quotiented, and that we have the
expected induction principle for it (i.e. it's an initial CwF).

Usually, we specify additional *type formers* on the top of a CwF, like function types:

    Pi  : (A : Ty Γ) → Ty (Γ, A) → Ty Γ
	_   : (Pi A B)[σ] = Pi (A[σ]) (B[fst σ, 0])
	lam : Tm (Γ,A) B → Tm Γ (Pi A B)
	_   : (lam t)[σ] = lam (t[fst σ, 0])
	app : Tm Γ (Pi A B) → Tm (Γ, A) B
	_   : app (lam t) = t                  -- beta
	_   : lam (app t) = t                  -- eta

This definition for application exploits the CwF structure so that we can get nicely symmetric beta
and eta rules. But it's also equivalent to the "usual" application:

    app : Tm Γ (Pi A B) → (t : Tm Γ A) → Tm Γ (B[id, t])

Also, CwFs can be generalized to support many different sorts with context extensions. For example,
in cubical type theories we might have a sort and a separate kind of context extension for
intervals:

    Int   : Con → Set
	_,Int : Con → Con
	_,_   : (σ : Sub Γ Δ) → Int Γ → Sub Γ (Δ,Int)

Informally, this lets us mix interval binders and ordinary binders in a context, like as in Γ, x :
Nat, i : Int ⊢ i : Int. Formally, the `i : Int` is a different kind of context extension.

(A general description of theories with "sensible" contexts and substitutions is "second-order
generalized algebraic theory", see e.g.
https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2024.10 )


## The notation

In ordinary nameful notation for calculi, we assign names to certain terms, those which are iterated
weakenings of the zero De Bruijn index.

### 1. whitespace for substitution

This is a very simple thing that's easy to support in proof assistants, but I think that it improves
readability significantly. We write the following.

- `A σ` for `A[σ]`
- `t σ` for `t[σ]`
- `σ δ` for `σ ∘ δ`

### 2. giving name to the identity substitution

If we want to define a type, term of substitution, or more generally, some object depending on a
context, we can give a name to the identity substitution using `Λ`. When we refer to the bound name
from under a binder, we weaken the identity substitution, similarly to how De Bruijn variables get
weakened. Simple examples:

Redefining the identity substitution:

    id : Sub Γ Γ
	id := Λ γ. γ

Here, `γ` is the local name for the identity substitution, so it's just desugared to `id`.

Substitution composition:

    _∘_ : Sub Δ Ξ → Sub Γ Δ → Sub Γ Ξ
	σ ∘ δ := Λ γ. (σ (δ γ))

This desugars to `σ ∘ δ ∘ id = σ ∘ δ`.

Weakening:

    wk : Sub (Γ, A) Γ
	wk := Λ γ. fst γ

But we can also immediately "match" on an extended identity substitution, like this:

    wk := Λ (γ, α). γ

`(γ, α)` is definitionally the same as `id` under the `Λ` binder.

Zero index:

    0 : Tm (Γ, A) (A[wk])
	0 := Λ (γ, α). α

Since `(γ, α)` is `id`, `α` is `snd id` under the binder.

### 3. "ordinary" named binders

Named binders are as usual, desugaring to De Bruijn indices. Named projections get weakened under
binders the same way as named term variables.

Non-dependent function type:

   Fun : Ty Γ → Ty Γ → Ty Γ
   Fun A B := Λ γ. Pi A α. B γ

α is the name for the Pi-bound variable. This desugars to

   Fun A B := Pi A (B[fst id])

γ is mentioned under the Pi binder so it gets weakened once, from id to fst id.

Pointful non-dependent function application:

    app' : Tm Γ (Fun A B) → Tm Γ A → Tm Γ B
	app' f a := Λ γ. app f (γ, a)

Recall that

    app : Tm Γ (Pi A B) → Tm (Γ, A) B

So

    app f        : Tm (Γ, A) (B[wk])
	(γ, a)       : Sub Γ (Γ, A)
	app f (γ, a) : Tm Γ B

And app' desugars to

    app' f a := (app f)[id, a]

Simply-typed function composition:

    comp : Tm Γ (Fun B C) → Tm Γ (Fun A B) → Tm Γ (Fun A C)
	comp f g := Λ γ. lam α. app' (f γ) (app' (g γ) α)

Desugared:

    comp f g := lam (app' (f[wk]) (app' (g[wk]) 0))

Again, γ becomes wk (i.e. fst id) under the binder.

### 4. Notation for contexts and contextual types

We write the following:

- `Γ => Δ` for `Sub Γ Δ`
- `Γ => Ty` for `Ty Γ`
- `Γ => Tm A` for `Tm Γ A`

Moreover, we can bind a name for the identity substitution (and its components) already when writing
any of the above. Examples:

    wk : {A : Γ => Ty} → (γ : Γ, α : A γ) => Γ
	wk := Λ (γ, α). γ

	0 : {A : Γ => Ty} → (γ : Γ, α : A γ) => A γ
	0 := Λ (γ, α). α

The types are desugared as

    wk : {A : Ty Γ} → Sub (Γ, A[id]) Γ
	0  : {A : Ty Γ} → Tm (Γ, A[id]) (A[fst id])

The list of all names in scope that were bound in a context refers to the identity substitution. So
in the first occurrence of A γ in the type of 0, γ is the identity substitution. In the second
occurrence of A γ, (γ, α) is the identity substitution, so γ is wk.

We could have written the following:

    wk : {A : Γ => Ty} → (γ : Γ, α : A) => Γ
	0 : {A : Γ => Ty} → (γ : Γ, α : A) => A γ

because we know that those occurrences of γ desugar to the identity substitution. However, this can
be a bit dangerous, because we need to correctly keep track of scopes ourselves to be able to make
such omissions.

In general, it is safe to omit substitutions for things that are specified in *arbitrary* contexts.
For example, such are most type and term constructors:

    Nat  : Γ => Ty
	zero : Γ => Tm Nat
	suc  : (Γ => Tm Nat) → (Γ => Tm Nat)

We don't write

    zero : (γ : Γ) => Tm (Nat γ)

because `Nat` can be used in any context. Similarly, in

    plustwo : (Γ => Tm Nat) → (Γ => Tm Nat)
	plustwo n := Λ γ. suc (suc (n γ))

we don't write

	plustwo n := Λ γ. suc (suc (n γ) γ) γ

It seems to be good practice make the contextual dependencies explicit for things that we *quantify
over* but not for the specified components of a theory.

Above, we could also have

    plustwo n := suc (suc n)

but this again relies on mentally tracking that n is mentioned in the same context as its assumed
context.

## Equational reasoning

We only need extra "beta" and "eta" rules, to be able to do complete equational reasoning, without
desugaring our notation. Eta:

    Λ γ. A γ = A
    Λ γ. t γ = t
	Λ γ. σ γ = σ

Beta:

	(Λ γ. A) δ = A[γ ↦ δ]
	(Λ γ. t) δ = t[γ ↦ δ]
	(Λ γ. σ) δ = σ[γ ↦ δ]

Eta rules are obvious, while beta rules are a bit more complicated, formally speaking. The
"meta-substitution" operation `_[_↦_]` works the same as ordinary capture-avoiding substitution.


--------------------------------------------------------------------------------

completely nameless substitution + equational reasoning

- type and term formers are never lambda-ed
- *unknown*, i.e. quantified terms are lambda-ed
- there's a substitution rule for each term and type former, that's
  *capture-avoiding*

    (lam x. t) γ = lam x. t γ           if x ∉ FV(γ)
 	(lam x. t) γ = lam y. (t[x↦y]) γ    if x ∈ FV(γ)







<!-- Examples for reasoning: -->

<!--     comp (lam x. x) (lam x. x)                               = -->
<!-- 	Λ γ. lam α. app' ((lam x. x) γ) (app' ((lam x. x) γ) α)  = -->
<!-- 	Λ γ. lam α. app' ((lam x. x) γ) (app' ((lam x. x) γ) α)  =	 -->






















































   <!-- app : Tm Γ (A => B) → Tm Γ A → Tm Γ B -->
   <!-- app f a = Λ γ. app f (γ, a) -->

   <!-- compose : Tm Γ (B => C) → Tm Γ (A => B) → Tm Γ (A => C) -->
   <!-- compose f g = Λ γ. -->
























The main idea is to also assign names to certain substitutions: the iterated weakenings. There's not much
more to it!

Let's start with a minimal example. We have the embedded syntax of some theory, as a CwF with type
formers. We only assume Pi as before now. We define a trivial "copy" operation by recursion on
terms, which just rebuilds the same term, and we don't do anything with contexts, types and
substitutions. In a nameless Agda-like notation, we might write something like:

    copy : Tm Γ A → Tm Γ A
	copy (snd σ) := snd σ
	copy (t[σ])  := (copy t)[σ]
	copy (app t) := app (copy t)
	copy (lam t) := lam (copy t)

These four cases cover every possible way of constructing a term in a CwF+Pi, so it's enough to
interpret them to get a recursive function on terms. Also, we need to show that all term equations
are preserved, but that's trivial here and we skip it.

In nameful notation:

    copy : Tm Γ A → Tm Γ A
	copy (snd σ) := Λ γ. snd σ γ
	copy (t[σ])  := Λ γ. copy t (σ γ)
	copy (app t) := Λ (γ, α). app (copy t γ, α)
	copy (lam t) := Λ γ. lam α. copy t (γ, α)

- We use Λ to introduce names for substitutions.
- We overload whitespace for substitution and for substitution composition,
  i.e. we can use "t σ" instead of t[σ] and "σ δ" instead of σ ∘ δ.
- If I write Λ γ., then γ is the name of the identity substitution from some Γ
  to Γ.  When I refer to γ from under some binders, it gets weakened the same
  way as ordinary term variables in nameful notation.
- If I write Λ (γ, α), then (γ, α) refers to the identity substitution from some
  (Γ,A) to (Γ,A), so γ is now fst id and α is snd id. Again, everything gets
  weakened when we use names from under binders.
- I use the standard desugaring scheme for ordinary term binders such as lam.

Let's mechanically desugar the above right hand sides:

    (Λ γ. snd σ γ) = (snd σ)[id] = snd σ
	(Λ γ. copy t (σ γ)) = (copy t)[σ ∘ id] = (copy t)[σ]
	(Λ (γ, α). app (copy t γ, α)) = app ((copy t)[fst id, snd id]) = app ((copy t)[id]) = app (copy t)
	(Λ γ. lam α. copy t (γ, α)) = lam ((copy t)[fst id, snd id]) = lam ((copy t)[id]) = lam (copy t)

Let's redefine some basic terms and substitutions in a nameful way:

    id : Sub Γ Γ    wk : Sub (Γ, A) Γ
	id := Λ γ. γ    wk = Λ (γ,_). γ

	_∘_ : Sub Δ Ξ → Sub Γ Δ → Sub Γ Ξ
	σ ∘ δ := Λ γ. σ (δ γ)

	0 : Tm (Γ,A) (A[wk])
	0 := Λ (_,α). α

However, we can already be nameful in contexts as well, like:

    0 : Tm (γ : Γ, α : A γ) (A γ)
	0 := Λ (_, α). α

The desugaring of **contexts** is as follows:

- If I write `γ : Γ`, I bring into scope `γ` as the identity substitution.
- In each context extension, the type implicitly binds everything on the left, and
  with each new binder we weaken all names in scope.
- In Tm Γ A, the type A can refer to names from  Γ
- In Sub Γ Δ, Δ can refer to names from Γ.

The previous type for 0 is desugared as follows:

    Tm (γ : Γ, α : A γ) (A γ) = Tm (Γ, A[id]) (A[fst id]) = Tm (Γ, A) (A[wk])

Lastly, let me introduce the following additional sugary notation:

- We may write Γ => Ty   instead of Ty Γ
- We may write Γ => Tm A instead of Tm Γ A
- We may Write Γ => Δ    instead of Sub Γ Δ

Thus, we may write:

    0 : (γ : Γ, A γ) => Tm (A γ)
	0 := Λ (_, α). α

	id : Γ => Γ
	id := Λ γ. γ

## Specifying some type formers, namefully

While the Pi type is pretty easy to specify in unnamed CwF operations, if we
want to rigorously write out specifications for complicated inductive types
like identity types or W-types, that's surprisingly tedious.

Let's start with the somewhat simpler **natural numbers**.

    Nat  : Γ => Ty
	zero : Γ => Tm Nat
	suc  : (Γ => Tm Nat) → (Γ => Tm Nat)

Here, note that we write Γ => Tm Nat instead of (γ : Γ) => Tm (Nat γ). This is
justified, since (γ : Γ) => Tm (Nat γ) is the same as (γ : Γ) => Tm (Nat[id]),
which is Γ => Tm Nat.

In general, we could just drop every identity substitution in the notation, but
it's probably not a good idea. In the case of Nat, since Nat, zero and suc are
all defined in arbitrary contexts, we can write them anywhere without having to
care about supplying the correct substitution.

The elimination principle:

    NatElim : (P  : (Γ, Nat) => Ty)
	          (pz : (γ : Γ) => Tm (P (γ, zero)))
			  (ps : (γ : Γ, n : Nat, P (γ, n)) => Tm (P (γ, suc n)))
			  (n  : Γ => Tm Nat)
	        → ((γ : Γ) => Tm (P (γ, n)))

This desugars to:

    NatElim : (P  : Ty (Γ, Nat))
	          (pz : Tm Γ (P[id, zero]))
			  (ps : Tm (Γ, Nat, P) (P[fst (fst id), suc (snd (fst id))]))
			  (n  : Tm Γ Nat)
	        → Tm Γ (P[id, n])

We also have some equations:

    _ :  NatElim P pz ps n σ
	   = NatElim (Λ (γ,n). P(γ σ, n)) (pz σ) (Λ (γ, n, pn). ps (γ σ, n, pn)) (n σ)

    _ : NatElim P pz ps zero    = pz
	_ : NatElim P pz ps (suc n) = Λ γ. ps (γ, n, NatElim P pz ps n)

Note that I can choose to "eta-expand" or not expand terms. For example,

    pz : (γ : Γ) => Tm (P (γ, zero))
	σ  : Δ => Γ

So

	pz σ = pz[σ]   -- desugared type: Tm Δ (P [σ, zero])

But also

    (Λ γ. pz (γ σ)) = pz[id ∘ σ] = pz[σ]

I can also eta-expand equations. Instead of having

    NatElim P pz ps zero = pz

I could write

    NatElim P pz ps zero γ = pz γ

where γ is universally quantified, and it means the same. I already hinted at this in
the suc beta rule:

    NatElim P pz ps (suc n) = Λ γ. ps (γ, n, NatElim P pz ps n)

here the RHS desugars to

    ps[id, n, NatElim P pz ps n]

but I can also write, for universally quantified γ:

    NatElim P pz ps (suc n) γ = ps (γ, n, NatElim P pz ps n)

Let's continue with the **identity type**. A first attempt:

    Id   : {A : Γ => Ty} → ((γ : Γ) => Tm (A γ)) → ((γ : γ) => Tm (A γ)) → Γ => Ty
	refl : (t : (γ : Γ) => Tm (A γ)) → ((γ : Γ) => Tm (Id (t γ) (t γ))

This is still tolerable, but at this point we might want to switch to a
specification which is better suited to nameful notation.

    Id   : {A : Γ => Ty} → (γ : Γ, A γ, A γ) => Ty
	refl : {A} → (γ : Γ, t : A γ) => Tm (Id {A} t t)

	_    : Id {A} (σ, x, y) = Λ γ. Id {A σ} (γ, x, y)
	_    : refl {A} (σ, t)  = Λ γ. refl {A σ} (γ, t)

	J    : {A  : Γ => Ty}
	       {a  : (γ : Γ) => Tm (A γ)}
		   (B  : (γ : Γ, a' : A γ, e : Id (γ, a γ, a')) => Ty)
		   (Br : (γ : Γ) => Tm (B (γ, a γ, refl (a γ))))
		   →
		   (γ : Γ, a' : A γ, e : Id (γ, a γ, a')) => Tm (B (γ, a γ, a', e))

    _    : J {A}{a} B Br (σ, a', e) = Λ γ. J {A σ}{a σ}(Λ (δ, a', e). B (δ σ, a', e))(Br σ) (γ, a', e)

	_    : J {A}{a} B Br (γ, a, refl a) = Br γ
